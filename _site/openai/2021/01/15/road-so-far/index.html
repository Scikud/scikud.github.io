<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>The road so far .... &#8211; ForceMultiplied</title>
    <link rel="dns-prefetch" href="//fonts.googleapis.com">
    <link rel="dns-prefetch" href="//fonts.gstatic.com">
    <link rel="dns-prefetch" href="//maxcdn.bootstrapcdn.com">
    <link rel="dns-prefetch" href="//cdnjs.cloudflare.com">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="A summary">
    <link rel="manifest" type="application/manifest+json; charset=utf-8" href="/manifest.json" />
    <meta name="robots" content="all">
    <meta name="author" content="Kudzo Ahegbebu">
    
    <meta name="keywords" content="OpenAI">
    <link rel="canonical" href="http://localhost:4000/openai/2021/01/15/road-so-far/">
    <link rel="alternate" type="application/rss+xml" title="RSS Feed for ForceMultiplied" href="/feed.xml" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/pixyll.css?202102252333" type="text/css">

    <!-- Fonts -->
    
    <link href='//fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Lato:900,300' rel='stylesheet' type='text/css'>
    
    

    <!-- MathJax -->
    

    <!-- Verifications -->
    
    

    <!-- Open Graph -->
    <!-- From: https://github.com/mmistakes/hpstr-jekyll-theme/blob/master/_includes/head.html -->
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="article">
    <meta property="og:title" content="The road so far ....">
    <meta property="og:description" content=".">
    <meta property="og:url" content="http://localhost:4000/openai/2021/01/15/road-so-far/">
    <meta property="og:site_name" content="ForceMultiplied">
    

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary" />
    
    <meta name="twitter:title" content="The road so far ...." />
    <meta name="twitter:description" content="A summary" />
    <meta name="twitter:url" content="http://localhost:4000/openai/2021/01/15/road-so-far/" />
    

    <!-- Icons -->
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" href="/favicon-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/favicon-160x160.png" sizes="160x160">
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
    <link rel="shortcut icon" href="/favicon.ico">

    
    <script type="text/javascript">
       (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
       (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
       m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
       })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
       ga('create', 'UA-110849882-1', 'auto');
       ga('send', 'pageview');
    </script>
    
</head>

<body class="site animated fade-in-down">
  
	

  <div class="site-wrap">
    <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="/" class="site-title">ForceMultiplied</a>
      <nav class="site-nav">
        



    
    
    
    
        <a class="nav-link" href="/404.html">404</a>
    

    

    
    
    
    
        <a class="nav-link" href="/contact/">Say Hello</a>
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    


      </nav>
      <div class="clearfix"></div>
      
    </div>
  </div>
</header>


    <div class="post p2 p-responsive wrap" role="main">
      <div class="measure">
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
  type="text/javascript"></script>



<div class="post-header mb2">
  <h1>The road so far ....</h1>
  <span class="post-meta">Jan 15, 2021</span><br>
  
  <span class="post-meta small">
    
    5 minute read
    
  </span>
</div>

<article class="post-content">
  <h3 id="what-ive-been-thinking-about">What i’ve been thinking about</h3>
<p>This post will largely be a recap of the past month of trying to resolve a clearer picture of my research direction for the remainder of the scholar’s program.</p>

<p>The motivating question behind my research thus far is whether or not it possible to make more optimal use of the compute resources available at test time in order to refine the output produced by a machine learning model. To rephrase:</p>

<p><em>If we’re being clever can we create constructions such that smaller adaptive models can instead leverage test time compute to overcome the handicap of having a smaller number of learnable parameters?</em></p>

<p>For deep learning models there seems exists an asymmetry between training and inference (test time) compute. State of the art models are typically trained with large compute budgets and subsequently deployed on machines which use significantly smaller computational resources. Does this represent an inefficient underutilization of computation? Put succinctly: are there ways to remedy the asymmetry of training vs test compute?</p>

<p>Anthropomorphically, I think there’s good motivation here. After all, given more time to think, humans generally tend to produce higher quality answers- perhaps by spending those additional cognitive resources on resolving ambiguity.</p>

<p>There are a number of particularly interesting approaches to this problem some of which i’ve talked about or hinted at in previous posts. Given the short time constraints of the scholar’s research program however, I think it makes sense to limit the scope of this investigation to just two potential avenues , namely the effects of adding in temporal recurrence into fast autoregressive transformers, and the effect  of adding externalized memory into existing models.  The  general idea here is that maybe the addition of temporal recurrence will enable training of transformer models which can iteratively refine their outputs (at least in language modeling contexts) while simultaneously decreasing sampling complexity and alleviating the per parameter computational cost increases seen in typical depth-wise recurrent architectures.</p>

<h3 id="a-detour-into-city-paths">A detour into city paths</h3>

<p>Both as a mechanism for investigating test time compute, and as a “fail fast” test i’ve constructed a dataset that’s turned out to be surprising in a number of ways.  For now what i’m just calling “The City Dataset” (Github link forthcoming I swear) was made by constructing a DAG from publicly available data about US population centers. It includes some basic demographic information as well as GPS coordinates for almost 30,000 distinct cities and municipalities distributed across the nation. Besides serving as a traversable knowledge graph, this DAG allows us to also construct simpler smaller datasets.</p>

<p>Particularly, one of these derivative datasets is the “Shortest Path Dataset” (SPD). SPD is constructed using the coordinates found in the City Dataset and uses Dijkstra’s to enumerates several million “shortest paths” between pairs of US cities.  I treat this a sequence modeling task using a scheme akin to traditional language modeling where the network is asked to given a sequence of inputs and asked at each timestep to predict the next token (city) in the sequence target. A RNN was constructed as baseline (from which we could later compare other models trained with similar levels of compute but utilizing increased compute at test time).</p>

<p style="text-align: center;"><img src="/images/cityRNNPerformance.png" alt="iterativeModel" /></p>

<p>Above, I plot performance for different sized architectures.  Notice that training loss tends to bottom out on the order 0.3~0.4. Because cross entropy loss isn’t a particularly useful metric in this case I constructed other metrics that measure the performance of the model along certain axes. Namely:</p>
<ol>
  <li>Do the generated output paths lack illegal jumps? Here Illegal jumps are defined as jumps between two cities that are over the “connected distance” used to generate the DAG - the distance below which we consider two cities to be connected.</li>
  <li>Is the length of the total path traversed by the generated output bounded? In other words, this metric checks to ensure that even if we don’t generate the exact optimal path, the path that we do generate deviates from the optimal path only by a small amount.</li>
  <li>Does the generated output actually end in the same city as the optimal path?</li>
</ol>

<p>What’s remarkable is that even with a somewhat  decent training loss, performance with regard to the these other metrics is abysmal. It’s still a bit early to say definitively but as far as I can tell, even with low NLL loss generating a sample output that satisfies even one of these metrics is <em>exceedingly, exceptionally</em> rare.</p>

<p>Despite it’s artificiality, it’s important to remember it’s not actually solving this particular task itself I care about.  What was important here was finding a domain that was sufficiently challenging where the benefits of leveraging compute at test time would be clear. Shortest Path seems attractive because any traditional single pass architecture should be algorithmically bounded in how well it should perform on this. Additionally, as an example of test time compute it’s easy to imagine a model that first generates a path that’s directionally correct and then continually refines its output. What’s a bit surprising about this task is how difficult its actually proven to be even with respect to generating just decently-performing baselines.</p>

<h3 id="to-be-continued">To be continued</h3>

<p>There’s quite a bit going through my head currently. I’m devising better means to instrument what’s going on with this dataset as well as mechanisms to actually extract performance with increases in test time compute from other models using other paradigms. Above all, while i’m bullish on the idea of test time compute, I still have deep doubts about the kludgyness and crudity of my methods. I would like to leave you with something more cogent, more coherent, and more insightful but for now i’m stumbling around in the darkness. Anyway, that’s it for now. Catch you on the flip.</p>


</article>










      </div>
    </div>
  </div>

  <footer class="center">
  <div class="measure">
    <small>
      Theme available on <a href="https://github.com/johnotander/pixyll">GitHub</a>.
    </small>
  </div>
</footer>

<script type="text/javascript">
  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.register("/sw.js")
  }
</script>
</body>
</html>
